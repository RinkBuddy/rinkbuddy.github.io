<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rink Templates</title>
<style>
  :root { --btn:#1f7aff; --danger:#ff4d4f; --dot-size:40px; --hdrH:64px; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{ margin:0; background:#000; color:#e9eef9; font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }

  header{
    position:sticky; top:0; z-index:30;
    display:grid; grid-template-columns:auto 1fr auto auto auto; gap:10px; align-items:center;
    padding:10px 12px; background:#0b0d13; border-bottom:1px solid #1b1e27;
  }
  .left,.center,.right{display:flex; gap:10px; align-items:center}
  .center{justify-content:center}
  .right{justify-content:flex-end}

  .btn{
    appearance:none; border:0; border-radius:999px; padding:10px 14px;
    font-weight:700; color:#fff; cursor:pointer; background:var(--btn);
    box-shadow:0 6px 14px rgba(31,122,255,.18);
  }
  .btn.secondary{ background:#22304b; border:1px solid #2b3a59; }
  .btn.danger{ background:var(--danger); }
  .btn:disabled{opacity:.6; cursor:not-allowed}
  .btn.saved{ background:#2a354f !important; color:#bcd4ff !important; }

  select, input[type="text"]{
    background:#121623; color:#fff; border:1px solid #1f2637; border-radius:10px; padding:10px 12px; min-width:260px;
    font-weight:600;
  }
  .name-wrap{display:flex; align-items:center; gap:8px}
  .name-wrap label{color:#9fb0d0; font-weight:700}
  .error{font-size:12px; color:#ff696b; margin-left:8px; display:none}
  .error.show{display:inline}

  .iconbtn{ padding:0; border:0; background:transparent; display:inline-grid; place-items:center; cursor:pointer; }
  .iconbtn img{ display:block; width:32px; height:32px; }
  .iconbtn.off img{ filter:grayscale(1) opacity(.45); }
  .iconbtn:focus-visible{ outline:2px solid #1f7aff; outline-offset:2px; }

  .stage{ display:flex; justify-content:center; align-items:center; width:100%; }
  .viewport{
    position:relative; margin:10px auto 0; border:1px solid #191c26; border-radius:14px;
    overflow:hidden; box-shadow:0 6px 24px rgba(0,0,0,.35); background:#000;
  }
  .viewport.placing{ cursor:crosshair; }
  canvas#rink { display:block; width:100%; height:100%; }

  .guide{ position:absolute; background:#00c2ff; opacity:.95; pointer-events:none; }
  .guide.v{ top:0; bottom:0; width:2px; left:50%; transform:translateX(-1px); }
  .guide.h{ left:0; right:0; height:2px; top:50%; transform:translateY(-1px); }

  .dot{
    position:absolute; transform:translate(-50%,-50%); width:var(--dot-size); height:var(--dot-size);
    border-radius:999px; background:#1976d2; border:2px solid #fff; box-shadow:0 4px 12px rgba(0,0,0,.4);
    display:grid; place-items:center; color:#fff; font-weight:800; user-select:none; cursor:grab; touch-action:none;
  }
  .dot:active{cursor:grabbing}
  .dot.selected{outline:3px solid #00e0b8}
  .viewport.placing .dot{ pointer-events:none; }

  /* DOOR */
  .door{
    position:absolute; transform-origin:50% 50%;
    background:#ffd600; color:#000; border:2px solid #000;
    border-radius:6px; font-weight:900; letter-spacing:1px;
    display:flex; align-items:center; justify-content:center;
    user-select:none; cursor:grab; touch-action:none;
    box-shadow:0 6px 18px rgba(0,0,0,.35);
  }
  .door:active{cursor:grabbing}

  .hidden{display:none !important}
  .auth-loading .app{visibility:hidden}

  @media (min-width: 901px){
    .stage{ min-height: calc(100vh - var(--hdrH)); }
  }
  @media (max-width: 900px){
    html, body { height: 100svh; overflow: hidden; }
    header{
      position:fixed; top:0; left:0; right:0; z-index:40;
      display:flex; gap:10px; align-items:center;
      overflow-x:auto; overflow-y:hidden; white-space:nowrap;
      -webkit-overflow-scrolling:touch; scrollbar-width:none;
    }
    header::-webkit-scrollbar{display:none}
    .left,.center,.right{display:inline-flex; gap:10px; align-items:center}
    .app{ padding-top: var(--hdrH); height: 100svh; overflow:hidden; }
    .stage{ height: calc(100svh - var(--hdrH)); align-items:center; justify-content:center; }
    .viewport{ margin:6px auto 0; }
  }
</style>
</head>
<body class="auth-loading">
<header>
  <div class="left">
    <button id="homeBtn" class="btn secondary">Home</button>
    <button id="newTplBtn" class="btn secondary">Create New Template</button>
  </div>

  <div class="center" id="pickerRow">
    <select id="templateSelect">
      <option value="">Select a template…</option>
    </select>
  </div>

  <div class="center hidden" id="nameRow">
    <div class="name-wrap">
      <label for="templateName">Template Name:</label>
      <input id="templateName" type="text" placeholder="Custom" />
      <span id="nameError" class="error">Name already used.</span>
    </div>
  </div>

  <div class="right">
    <div id="editTools" class="hidden" style="display:flex;gap:10px;align-items:center">
      <button id="addBtn" class="btn">+ New Point</button>
      <button id="symBtn" class="iconbtn" title="Toggle symmetry (on/off)" aria-pressed="true">
        <img src="symmetry.png" alt="Symmetry">
      </button>
      <button id="delBtn" class="btn danger" disabled>Delete Selected</button>
    </div>
    <button id="saveBtn" class="btn" disabled>Save</button>
    <button id="loginBtn" class="btn hidden">Sign in with Google</button>
  </div>
</header>

<div class="app">
  <div class="stage">
    <div id="view" class="viewport">
      <canvas id="rink"></canvas>
      <div id="guide" class="guide v"></div>
      <div id="door" class="door">DOOR</div>
    </div>
  </div>
</div>

<script type="module">
import { initializeApp, getApps } from "https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js";
import {
  getAuth, GoogleAuthProvider, signInWithPopup,
  onAuthStateChanged, setPersistence, browserLocalPersistence
} from "https://www.gstatic.com/firebasejs/10.13.1/firebase-auth.js";
import {
  getFirestore, doc, collection, getDocs, getDoc, setDoc
} from "https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyCYlPYVyeUMpcr8qgUTifHJiOCayhh7QCQ",
  authDomain: "rink-buddy-6f6ed.firebaseapp.com",
  projectId: "rink-buddy-6f6ed",
  storageBucket: "rink-buddy-6f6ed.appspot.com",
  messagingSenderId: "1096930052063",
  appId: "1:1096930052063:web:6b97608f1cdd3f5111666a",
  measurementId: "G-7HPRJ6T9LD"
};
const app = getApps().length ? getApps()[0] : initializeApp(firebaseConfig);
const auth = getAuth(app);
const db   = getFirestore(app);
await setPersistence(auth, browserLocalPersistence);

/* DOM */
const view = document.getElementById('view');
const canvas = document.getElementById('rink');
const ctx = canvas.getContext('2d', { willReadFrequently:true });
const guide = document.getElementById('guide');
const doorEl = document.getElementById('door');

const homeBtn = document.getElementById('homeBtn');
const newTplBtn = document.getElementById('newTplBtn');
const templateSelect = document.getElementById('templateSelect');
const nameRow = document.getElementById('nameRow');
const pickerRow = document.getElementById('pickerRow');
const templateName = document.getElementById('templateName');
const nameError = document.getElementById('nameError');

const editTools = document.getElementById('editTools');
const addBtn = document.getElementById('addBtn');
const symBtn = document.getElementById('symBtn');
const delBtn = document.getElementById('delBtn');
const saveBtn = document.getElementById('saveBtn');
const loginBtn = document.getElementById('loginBtn');

/* State */
const img = new Image(); img.src = 'rink1.png';

const state = {
  naturalW: 600, naturalH: 1200,
  mobile: false,
  rotated: false,
  centerY: 0.5,
  snapPx: 12,
  symmetry: true,
  points: [],
  selectedIndex: null,
  maskData: null,
  placing: false,
  uid: null,
  allNames: [],
  currentName: null,
  creating: false,
  dirty: false,
  door: { edge: 0, t: 0.5 },
  doorLen: 100,
  doorThick: 20
};

/* Dirty/Saved */
function setDirty(on){
  state.dirty = !!on;
  if (on){
    saveBtn.disabled = false;
    saveBtn.classList.remove('saved');
    saveBtn.textContent = 'Save';
  }else{
    saveBtn.disabled = true;
    saveBtn.classList.add('saved');
    saveBtn.textContent = 'Saved';
  }
}
function clearDirtyAfterLoad(){
  if (editTools.classList.contains('hidden')) {
    saveBtn.disabled = true;
    saveBtn.classList.remove('saved');
    saveBtn.textContent = 'Save';
  } else {
    setDirty(false);
  }
}

/* Auth */
document.body.classList.add('auth-loading');
onAuthStateChanged(auth, async (user) => {
  document.body.classList.remove('auth-loading');
  if (!user) {
    loginBtn.classList.remove('hidden');
    editTools.classList.add('hidden');
    saveBtn.disabled = true;
    await ensureCanvasReady();
    return;
  }
  loginBtn.classList.add('hidden');
  state.uid = user.uid;
  await refreshTemplateList();
  await ensureCanvasReady();
  setEditingEnabled(false);
});
loginBtn.addEventListener('click', async ()=>{
  const provider = new GoogleAuthProvider();
  await signInWithPopup(auth, provider);
});

/* Firestore */
function userDocRef(uid){ return doc(db, 'users', uid); }
function templatesColRef(uid){ return collection(userDocRef(uid), 'templates'); }
function templateDocRef(uid, name){ return doc(templatesColRef(uid), name); }

async function refreshTemplateList(){
  if (!state.uid) return;
  const snap = await getDocs(templatesColRef(state.uid));
  state.allNames = snap.docs.map(d=>d.id).sort((a,b)=> a.localeCompare(b));
  templateSelect.innerHTML = `<option value="">Select a template…</option>`;
  state.allNames.forEach(n=>{
    const opt = document.createElement('option');
    opt.value = n; opt.textContent = n;
    templateSelect.appendChild(opt);
  });
}

async function loadTemplateByName(name){
  const ref = templateDocRef(state.uid, name);
  const docSnap = await getDoc(ref);
  if (!docSnap.exists()) return false;
  const data = docSnap.data();
  state.currentName = name;
  ingestTemplateJSON(data);
  setEditingEnabled(true);
  saveBtn.disabled = false;
  templateSelect.value = name;
  setCreateMode(false);
  clearDirtyAfterLoad();
  return true;
}

async function saveTemplate(){
  if (!state.uid) return;
  if (!state.currentName || (state.creating && !isNameAvailable(state.currentName))) return;

  const docBody = {
    name: state.currentName,
    imagePath:'rink1.png',
    imgW: state.naturalW, imgH: state.naturalH,
    centerY: state.centerY, snapPx: state.snapPx,
    points: state.points.map(p=>({ id:p.id, u:+p.u.toFixed(6), v:+p.v.toFixed(6), mode:p.mode })),
    door: { edge: state.door.edge, t: +state.door.t.toFixed(6) },
    updatedAt: new Date().toISOString(), version: 4
  };
  await setDoc(templateDocRef(state.uid, state.currentName), docBody);
  await refreshTemplateList();
  templateSelect.value = state.currentName;
  state.creating = false;
  setEditingEnabled(true);
  setDirty(false);
}

/* Name validation */
function isNameAvailable(name){
  if (!name) return false;
  if (name.includes('/')) return false;
  return !state.allNames.map(x=>x.toLowerCase()).includes(name.toLowerCase());
}
function updateNameValidation(){
  const name = templateName.value.trim() || 'Custom';
  state.currentName = name;
  const ok = isNameAvailable(name);
  nameError.textContent = name.includes('/') ? 'Name cannot include "/"' : 'Name already used.';
  nameError.classList.toggle('show', !ok);
  if (state.creating) saveBtn.disabled = !ok;
}

/* Header actions */
homeBtn.addEventListener('click', ()=>{ window.location.href = 'index.html'; });
newTplBtn.addEventListener('click', ()=>{
  setCreateMode(true);
  state.currentName = 'Custom';
  templateName.value = 'Custom';
  updateNameValidation();
  resetRink();
  setEditingEnabled(true);
  clearDirtyAfterLoad();
});
templateSelect.addEventListener('change', async (e)=>{
  const name = e.target.value;
  if (!name) { setEditingEnabled(false); resetRink(); clearDirtyAfterLoad(); return; }
  await loadTemplateByName(name);
});
templateName.addEventListener('input', updateNameValidation);

function setCreateMode(on){
  state.creating = on;
  nameRow.classList.toggle('hidden', !on);
  pickerRow.classList.toggle('hidden',  on);
}
function setEditingEnabled(on){
  editTools.classList.toggle('hidden', !on);
  if (!on) { saveBtn.disabled = true; saveBtn.classList.remove('saved'); saveBtn.textContent = 'Save'; }
}

/* Canvas + layout */
const uid = () => (crypto?.randomUUID ? crypto.randomUUID() : 'pt_'+Date.now().toString(36)+'_'+Math.random().toString(36).slice(2,8));
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const isCenter=(v)=>Math.abs(v - state.centerY) < 1e-6;

function setCanvasSize(w,h){
  canvas.width  = Math.max(1, Math.round(w));
  canvas.height = Math.max(1, Math.round(h));
  view.style.width  = canvas.width + 'px';
  view.style.height = canvas.height + 'px';
}

function applyLayout(){
  const headerH = document.querySelector('header').offsetHeight || 64;
  document.documentElement.style.setProperty('--hdrH', headerH + 'px');

  state.mobile = window.matchMedia('(max-width: 900px)').matches;
  const imageIsVertical = state.naturalH > state.naturalW;
  const wantVertical    = state.mobile;
  state.rotated = (wantVertical !== imageIsVertical);

  let availW, availH;
  if (state.mobile){
    const stage = document.querySelector('.stage');
    availW = Math.max(1, stage.clientWidth  - 12);
    availH = Math.max(1, stage.clientHeight - 12);
    if (availW <= 1 || availH <= 1) { requestAnimationFrame(applyLayout); return; }
  } else {
    availW = Math.max(1, window.innerWidth  - 24);
    availH = Math.max(1, window.innerHeight - headerH - 24);
  }

  const aspect = state.rotated ? (state.naturalH/state.naturalW) : (state.naturalW/state.naturalH);
  let w = availW, h = w/aspect; if (h>availH){ h=availH; w=h*aspect; }
  setCanvasSize(w,h);

  guide.className = 'guide ' + (state.mobile ? 'h' : 'v');

  const d = Math.max(2, Math.round(Math.min(canvas.width, canvas.height) * 0.10));
  document.documentElement.style.setProperty('--dot-size', d + 'px');

  // DOOR size: 60% of previous
  const longSide = Math.max(canvas.width, canvas.height);
  state.doorLen   = Math.round(longSide * 0.20 * 0.6);
  state.doorThick = Math.max(8, Math.round(state.doorLen * 0.16));
  doorEl.style.width = state.doorLen + 'px';
  doorEl.style.height = state.doorThick + 'px';
  doorEl.style.fontSize = Math.round(state.doorThick*0.55) + 'px';
  doorEl.style.lineHeight = state.doorThick + 'px';

  drawRink();
  cacheMask();
  renderDots();
  positionDoor();
}

function drawRink(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if (state.rotated){
    // CCW 90° so portrait UVs are not mirrored
    ctx.save();
    ctx.translate(0, canvas.height);
    ctx.rotate(-Math.PI/2);
    ctx.drawImage(img, 0, 0, canvas.height, canvas.width);
    ctx.restore();
  } else {
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  }
}
function cacheMask(){ try{ state.maskData = ctx.getImageData(0,0,canvas.width,canvas.height).data; }catch{ state.maskData=null; } }

/* UV <-> canvas */
function uvToCanvas(u,v){
  const W=canvas.width, H=canvas.height;
  if (state.mobile) return { x: u*W, y: v*H };
  return { x: v*W, y: (1 - u)*H };  // CCW mapping for desktop
}
function canvasToUv(x,y){
  const W=canvas.width, H=canvas.height;
  const sx = clamp(x/W,0,1), sy = clamp(y/H,0,1);
  if (state.mobile) return { u: sx, v: sy };
  return { u: 1 - sy, v: sx };      // inverse
}

function clampUvLoose(u,v){ const mu=1/canvas.width, mv=1/canvas.height; return { u:clamp(u,mu,1-mu), v:clamp(v,mv,1-mv) }; }
function alphaAtCanvas(x,y){ if(!state.maskData) return 255; const W=canvas.width,H=canvas.height; const xi=Math.max(0,Math.min(W-1,x|0)), yi=Math.max(0,Math.min(H-1,y|0)); return state.maskData[(yi*W+xi)*4+3]; }
function centerOnIce(u,v){ const c=uvToCanvas(u,v); if(c.x<0||c.y<0||c.x>canvas.width||c.y>canvas.height) return false; return alphaAtCanvas(c.x,c.y)>=8; }

function projectInside(last, proposed){
  if (!state.maskData) return clampUvLoose(proposed.u, proposed.v);
  if (centerOnIce(proposed.u, proposed.v)) return proposed;
  if (!centerOnIce(last.u, last.v)) return last;
  let a={...last}, b={...proposed};
  for(let i=0;i<18;i++){ const m={u:(a.u+b.u)/2, v:(a.v+b.v)/2}; if(centerOnIce(m.u,m.v)) a=m; else b=m; }
  return a;
}

/* Dots */
function clearDots(){ view.querySelectorAll('.dot').forEach(n=>n.remove()); }
function renderDots(){
  clearDots();
  state.points.forEach((pt, idx) => {
    if (pt.mode === 'single'){
      addDotAtUV(pt.u, pt.v, idx, 'single', '');
    } else {
      if (isCenter(pt.v)){
        addDotAtUV(pt.u, state.centerY, idx, 'center', '');
      } else {
        const vTop = Math.min(pt.v, 2*state.centerY - pt.v);
        const vBot = Math.max(pt.v, 2*state.centerY - pt.v);
        addDotAtUV(pt.u, vTop, idx, 'top', '');
        addDotAtUV(pt.u, vBot, idx, 'bottom', '');
      }
    }
  });
}
function addDotAtUV(u,v, idx, side, text){
  const p=uvToCanvas(u,v);
  const d=document.createElement('div');
  d.className='dot'; d.dataset.idx=String(idx); d.dataset.side=side; d.dataset.mode=state.points[idx].mode;
  d.textContent=text||''; d.style.left=(p.x/canvas.width*100)+'%'; d.style.top=(p.y/canvas.height*100)+'%';
  if (state.selectedIndex===idx) d.classList.add('selected');
  d.addEventListener('pointerdown', onDragStart, {passive:false});
  d.addEventListener('click', (e)=>{ e.stopPropagation(); if(state.placing) return; state.selectedIndex=idx; delBtn.disabled=false; renderDots(); });
  view.appendChild(d);
}

/* Drag/Place */
let dragging=null;
function localXY(e){ const r=view.getBoundingClientRect(); return {x:e.clientX-r.left, y:e.clientY-r.top}; }
function onDragStart(e){
  if (state.placing) return;
  e.preventDefault();
  const idx=+e.currentTarget.dataset.idx; const pt=state.points[idx]; if(!pt) return;
  state.selectedIndex=idx; delBtn.disabled=false;
  dragging={idx, start:{u:pt.u, v:pt.v}, last:{u:pt.u, v:pt.v}, mode:pt.mode, side:e.currentTarget.dataset.side, wasOnCenter:isCenter(pt.v)};
  e.currentTarget.setPointerCapture(e.pointerId);
  window.addEventListener('pointermove', onDragMove, {passive:false});
  window.addEventListener('pointerup', onDragEnd, {passive:true});
}
function onDragMove(e){
  if(!dragging) return;
  const pt=state.points[dragging.idx];
  const {x,y}=localXY(e);
  let {u,v}=canvasToUv(x,y);
  ({u,v}=clampUvLoose(u,v));
  const eps = state.snapPx / canvas.height;
  const breakEps = eps * 1.2;
  if (dragging.mode === 'mirrored'){
    if (dragging.side === 'bottom') v = 2*state.centerY - v;
    v = Math.min(v, state.centerY);
    const dist=Math.abs(v-state.centerY);
    if (dist<=eps){ v=state.centerY; dragging.wasOnCenter=true; }
    else if (dragging.wasOnCenter && dist>breakEps){ dragging.wasOnCenter=false; }
    const proposed={u,v}; const resolved=centerOnIce(u,v)?proposed:projectInside(dragging.last,proposed);
    pt.u=resolved.u; pt.v=resolved.v; dragging.last=resolved;
  } else {
    const dist=Math.abs(v-state.centerY);
    if (dist<=eps){ v=state.centerY; dragging.wasOnCenter=true; }
    else if (dragging.wasOnCenter && dist>breakEps){ dragging.wasOnCenter=false; }
    const proposed={u,v}; const resolved=centerOnIce(u,v)?proposed:projectInside(dragging.last,proposed);
    pt.u=resolved.u; pt.v=resolved.v; dragging.last=resolved;
  }
  renderDots();
}
function onDragEnd(){
  if (!dragging) return;
  const moved = Math.hypot(dragging.last.u - dragging.start.u, dragging.last.v - dragging.start.v) > 1e-6;
  dragging=null;
  window.removeEventListener('pointermove', onDragMove);
  window.removeEventListener('pointerup', onDragEnd);
  if (moved) setDirty(true);
}

let placeHandler=null, escHandler=null;
function enterPlacing(){
  if (state.placing) return;
  state.placing=true; view.classList.add('placing'); addBtn.textContent='Click to place… (Esc to cancel)'; delBtn.disabled=true;
  placeHandler=(e)=>{
    const {x,y}=localXY(e); let {u,v}=canvasToUv(x,y); ({u,v}=clampUvLoose(u,v));
    const eps=state.snapPx/canvas.height; if (Math.abs(v-state.centerY)<=eps) v=state.centerY;
    if (!state.maskData || centerOnIce(u,v)){
      if (state.symmetry){ const vTop=Math.min(v, 2*state.centerY - v); state.points.push({id:uid(), u, v:vTop, mode:'mirrored'}); }
      else { state.points.push({id:uid(), u, v, mode:'single'}); }
      state.selectedIndex=null;
      setDirty(true);
    }
    exitPlacing(); renderDots();
  };
  escHandler=(e)=>{ if(e.key==='Escape') exitPlacing(); };
  view.addEventListener('pointerdown', placeHandler, {once:true});
  window.addEventListener('keydown', escHandler, {once:true});
}
function exitPlacing(){
  if(!state.placing) return;
  state.placing=false; view.classList.remove('placing'); addBtn.textContent='+ New Point';
  try{ view.removeEventListener('pointerdown', placeHandler, {once:true}); }catch{}
  try{ window.removeEventListener('keydown', escHandler, {once:true}); }catch{}
  placeHandler=escHandler=null;
}
addBtn.addEventListener('click', ()=>{ if(!editTools.classList.contains('hidden')){ state.placing?exitPlacing():enterPlacing(); }});
symBtn.addEventListener('click', ()=>{ state.symmetry=!state.symmetry; symBtn.classList.toggle('off', !state.symmetry); symBtn.setAttribute('aria-pressed', state.symmetry?'true':'false'); });
delBtn.addEventListener('click', ()=>{
  const i=state.selectedIndex; if(i==null) return;
  state.points.splice(i,1); state.selectedIndex=null; delBtn.disabled=true; renderDots(); setDirty(true);
});
view.addEventListener('pointerdown', (e)=>{ if(state.placing) return; if(e.target.classList.contains('dot')) return; state.selectedIndex=null; delBtn.disabled=true; renderDots(); });

/* DOOR — unified corner snap, closer to the edge */
function positionDoor(){
  const W=canvas.width, H=canvas.height;
  const L=state.doorLen, T=state.doorThick, halfL=L/2, halfT=T/2;

  // Nudge closer to visible edge/corner
  const edgeInset   = Math.min(halfT * 0.3, 10);
  const cornerInset = edgeInset;

  let edge = state.door.edge|0;            // 0 top,1 right,2 bottom,3 left
  let t = clamp(state.door.t,0,1);
  let cx=0, cy=0, angle=0;

  const cornerThresh = (edge===0 || edge===2) ? (halfL/W) : (halfL/H);

  // When near a corner, snap to a single canonical pose per corner
  if (t <= cornerThresh){
    if (edge===0 || edge===3){              // top-left
      const c = Math.max(halfT, halfL - cornerInset);
      cx = c; cy = c; angle = -45;
    } else if (edge===1){                    // top-right
      const c = Math.max(halfT, halfL - cornerInset);
      cx = W - c; cy = c; angle = 45;
    } else if (edge===2){                    // bottom-left (start of bottom)
      const c = Math.max(halfT, halfL - cornerInset);
      cx = c; cy = H - c; angle = 45;
    }
  } else if (t >= 1 - cornerThresh){
    if (edge===0){                           // top-right
      const c = Math.max(halfT, halfL - cornerInset);
      cx = W - c; cy = c; angle = 45;
    } else if (edge===1 || edge===2){        // bottom-right
      const c = Math.max(halfT, halfL - cornerInset);
      cx = W - c; cy = H - c; angle = -45;
    } else if (edge===3){                    // bottom-left
      const c = Math.max(halfT, halfL - cornerInset);
      cx = c; cy = H - c; angle = 45;
    }
  } else {
    // middle of edges (closer to edge)
    if (edge===0){ cx = t*W; cy = (halfT - edgeInset); angle = 0; }
    else if (edge===2){ cx = t*W; cy = H - (halfT - edgeInset); angle = 0; }
    else if (edge===1){ cx = W - (halfT - edgeInset); cy = t*H; angle = 90; }
    else { cx = (halfT - edgeInset); cy = t*H; angle = 90; }

    // prevent ends from overhanging rounded corners
    const minC = Math.max(halfT, halfL - cornerInset);
    if (edge===0 || edge===2) cx = clamp(cx, minC, W - minC);
    else                      cy = clamp(cy, minC, H - minC);
  }

  doorEl.style.left = (cx / W * 100) + '%';
  doorEl.style.top  = (cy / H * 100) + '%';
  doorEl.style.transform = `translate(-50%,-50%) rotate(${angle}deg)`;
}
function edgeTFromXY(x,y){
  const W=canvas.width, H=canvas.height;
  const dTop=y, dRight=W-x, dBottom=H-y, dLeft=x;
  const min = Math.min(dTop,dRight,dBottom,dLeft);
  if (min===dTop)   return { edge:0, t: clamp(x/W,0,1) };
  if (min===dRight) return { edge:1, t: clamp(y/H,0,1) };
  if (min===dBottom)return { edge:2, t: clamp(x/W,0,1) };
  return { edge:3, t: clamp(y/H,0,1) };
}
let draggingDoor=false;
doorEl.addEventListener('pointerdown',(e)=>{
  e.preventDefault();
  doorEl.setPointerCapture(e.pointerId);
  draggingDoor=true;
  window.addEventListener('pointermove', onDoorMove, {passive:false});
  window.addEventListener('pointerup', onDoorUp, {passive:true});
});
function onDoorMove(e){
  if(!draggingDoor) return;
  const {x,y}=localXY(e);
  const et = edgeTFromXY(x,y);
  state.door.edge = et.edge;
  state.door.t = et.t;
  positionDoor();
}
function onDoorUp(){
  if(!draggingDoor) return;
  draggingDoor=false;
  window.removeEventListener('pointermove', onDoorMove);
  window.removeEventListener('pointerup', onDoorUp);
  setDirty(true);
}

/* Reset / ingest */
function resetRink(){
  state.points=[]; state.selectedIndex=null; delBtn.disabled=true;
  state.door = { edge: 0, t: 0.5 };
  renderDots(); positionDoor();
}
function ingestTemplateJSON(data){
  resetRink();
  state.points = Array.isArray(data.points) ? data.points.map(p=>({
    id: p.id || uid(),
    u: +p.u, v: +p.v,
    mode: p.mode==='single' ? 'single' : 'mirrored'
  })) : [];
  if (data.door && Number.isFinite(data.door.edge) && Number.isFinite(data.door.t)){
    state.door.edge = clamp(data.door.edge|0,0,3);
    state.door.t = clamp(+data.door.t,0,1);
  }
  renderDots(); positionDoor();
}

/* Boot */
async function ensureCanvasReady(){
  if (img.complete) { state.naturalW=img.naturalWidth||state.naturalW; state.naturalH=img.naturalHeight||state.naturalH; applyLayout(); }
  else { await new Promise(res=>{ img.onload=()=>{ state.naturalW=img.naturalWidth||state.naturalW; state.naturalH=img.naturalHeight||state.naturalH; applyLayout(); res(); }; }); }
}
window.addEventListener('resize', applyLayout);
window.addEventListener('orientationchange', applyLayout);
new ResizeObserver(applyLayout).observe(document.querySelector('header'));

saveBtn.addEventListener('click', async ()=>{ await saveTemplate(); });
</script>
</body>
</html>

